name: Run Ansible Playbook
description: Runs Ansible with inventory generation and specified playbook using SSH key authentication.

inputs:
  ansible_hosts:
    description: 'Line-separated list of Ansible host IPs'
    required: true
  ansible_user:
    description: 'Ansible SSH username'
    required: false
    default: 'root'
  ssh_private_key:
    description: 'SSH private key for authentication'
    required: true
  playbook:
    description: 'Path to the Ansible playbook to run (relative to ansible/ directory)'
    required: true
  use_template_playbook:
    description: 'If true, use playbook from templates repo instead of calling repo'
    required: false
    default: 'false'
  ansible_extra_env_json:
    description: 'Additional environment variables as JSON object (non-sensitive)'
    required: false
    default: '{}'
  ansible_extra_secrets_json:
    description: 'Additional secrets as JSON object (sensitive)'
    required: false
    default: '{}'

runs:
  using: composite
  steps:
    - name: Setup SSH Agent
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ inputs.ssh_private_key }}

    - name: Dynamically Scan and Add Known Hosts
      run: |
        mkdir -p ~/.ssh
        # Read newline-separated hosts
        while IFS= read -r host; do
          # Skip empty lines
          if [ -n "$host" ]; then
            SCAN=$(ssh-keyscan -H "$host" 2>/dev/null)
            if [ -n "$SCAN" ]; then
              echo "$SCAN" >> ~/.ssh/known_hosts
              echo "Added $host to known_hosts"
            else
              echo "Warning: Failed to scan $host"
            fi
          fi
        done <<< "${{ inputs.ansible_hosts }}"
      shell: bash

    - name: Run Ansible Playbooks in Docker
      run: |
        # Helper function to escape control characters in JSON strings
        # This fixes common issues like unescaped newlines in private keys
        escape_json_string() {
          local json_str="$1"
          
          # Handle truly empty input (but not "{}" as a string - that's valid JSON)
          if [ -z "$json_str" ]; then
            echo "{}"
            return 0
          fi
          
          # If it's already the JSON object {}, return it
          if [ "$json_str" = "{}" ]; then
            echo "{}"
            return 0
          fi
          
          # Try to parse as-is first
          if echo "$json_str" | jq empty 2>/dev/null; then
            echo "$json_str"
            return 0
          fi
          
          # If parsing fails, use the helper script to fix control characters
          local escaped_json
          local temp_stderr
          temp_stderr=$(mktemp)
          
          # Capture stdout, let stderr go to stderr (will show in logs)
          escaped_json=$(echo "$json_str" | python3 "$GITHUB_ACTION_PATH/escape_json.py" 2>"$temp_stderr")
          local exit_code=$?
          
          if [ $exit_code -ne 0 ]; then
            echo "Error: Failed to escape JSON string" >&2
            [ -s "$temp_stderr" ] && cat "$temp_stderr" >&2
            rm -f "$temp_stderr"
            return 1
          fi
          
          rm -f "$temp_stderr"
          
          # Ensure we got valid JSON output
          if [ -z "$escaped_json" ] || ! echo "$escaped_json" | jq empty 2>/dev/null; then
            echo "Error: Escaped JSON is invalid or empty" >&2
            return 1
          fi
          
          echo "$escaped_json"
        }
        
        # Validate and merge extra env vars and secrets JSONs
        ENV_JSON_RAW='${{ inputs.ansible_extra_env_json }}'
        SECRETS_JSON_RAW='${{ inputs.ansible_extra_secrets_json }}'
        
        echo "Processing JSON inputs (ENV length: ${#ENV_JSON_RAW}, SECRETS length: ${#SECRETS_JSON_RAW})"
        
        # Escape control characters if needed
        if ! ENV_JSON=$(escape_json_string "$ENV_JSON_RAW"); then
          echo "Error: Failed to process ansible_extra_env_json"
          exit 1
        fi
        
        if ! SECRETS_JSON=$(escape_json_string "$SECRETS_JSON_RAW"); then
          echo "Error: Failed to process ansible_extra_secrets_json"
          exit 1
        fi
        
        echo "JSON processing complete (ENV: ${#ENV_JSON} chars, SECRETS: ${#SECRETS_JSON} chars)"
        
        # Ensure both are valid JSON objects
        ENV_JSON=$(echo "$ENV_JSON" | jq -c 'if . == null or . == "" then {} else . end' 2>/dev/null || echo "{}")
        SECRETS_JSON=$(echo "$SECRETS_JSON" | jq -c 'if . == null or . == "" then {} else . end' 2>/dev/null || echo "{}")
        
        # Validate both JSONs are objects
        if ! echo "$ENV_JSON" | jq 'type == "object"' -e >/dev/null 2>&1; then
          echo "Error: ansible_extra_env_json must be a JSON object"
          exit 1
        fi
        
        if ! echo "$SECRETS_JSON" | jq 'type == "object"' -e >/dev/null 2>&1; then
          echo "Error: ansible_extra_secrets_json must be a JSON object"
          exit 1
        fi
        
        # Merge the validated JSONs (both are guaranteed to be objects now)
        MERGED_JSON=$(jq -s '.[0] * .[1]' <(echo "$ENV_JSON") <(echo "$SECRETS_JSON"))
        
        # Parse merged JSON to Docker env flags
        EXTRA_ENV_FLAGS=()
        if [ "$MERGED_JSON" != "{}" ] && [ -n "$MERGED_JSON" ]; then
          echo "Parsing extra environment variables and secrets..."
          # Read jq output into array to handle multi-line values safely
          while IFS= read -r flag; do
            [ -n "$flag" ] && EXTRA_ENV_FLAGS+=("$flag")
          done < <(echo "$MERGED_JSON" | jq -r 'to_entries[] | "-e \(.key)=\(.value | @sh)"')
          echo "Extra environment flags configured (count: $(echo "$MERGED_JSON" | jq 'length'))"
        fi
        
        # Determine playbook path based on use_template_playbook flag
        if [ "${{ inputs.use_template_playbook }}" = "true" ]; then
          PLAYBOOK_PATH="templates/ansible/${{ inputs.playbook }}"
        else
          PLAYBOOK_PATH="ansible/${{ inputs.playbook }}"
        fi
        
        # Run Ansible with all environment variables
        docker run --rm \
          -v $GITHUB_WORKSPACE:/workspace \
          -v $SSH_AUTH_SOCK:/ssh-agent \
          -v ~/.ssh/known_hosts:/root/.ssh/known_hosts:ro \
          -e SSH_AUTH_SOCK=/ssh-agent \
          -e ANSIBLE_HOSTS="${{ inputs.ansible_hosts }}" \
          -e ANSIBLE_USER="${{ inputs.ansible_user }}" \
          "${EXTRA_ENV_FLAGS[@]}" \
          -w /workspace \
          ghcr.io/skiesgames/skiesdota-ci-cd-templates/ansible-prod:latest \
          bash -c "ansible-playbook templates/ansible/playbooks/generate_inventory.yml && ansible-playbook -i ansible/inventory.ini $PLAYBOOK_PATH"
      shell: bash
